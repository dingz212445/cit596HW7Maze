package maze;


import java.util.*;

/**
 *  Contains the maze struture, which is just an array of 
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 */


public class Maze {

    private int rows, cols;
    private MazeCell maze[][];
    //the UI code is all in MazeViewer.java
    private MazeViewer viewer;
    //This is just for random number generation
    private Random generator;
    private MazeCell startCell;
    private MazeCell endCell;
    
    private DisjointSet sets;

    /**
     *  Creates a maze that has the given number of rows and columns.
     *  Sets the neighbors of each cell.
     *  @param rows  Number of rows in the maze.
     *  @param cols  Number of columns in the maze.
     */
    public Maze(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        generator = new Random();

        // Create the maze.     
        maze = new MazeCell[rows][cols];
        for (int i=0; i<rows; i++) {
            for (int j=0; j<cols; j++) {
                maze[i][j] = new MazeCell();
            }
        }

        // Set the neighbors for each cell in the maze.
        for (int i=0; i<rows; i++) {
            for (int j=0; j<cols; j++) {
                MazeCell n, e, s, w;
                if (i == 0) n = null; // On north border of maze
                else n = maze[i-1][j]; 

                if (i == rows-1) s = null; // On south border of maze
                else s = maze[i+1][j];

                if (j == 0) w = null; // On west border of maze
                else w = maze[i][j-1];

                if (j == cols-1) e = null; // On east border of maze
                else e = maze[i][j+1];

                maze[i][j].setNeighbors(n,e,s,w);
            }
        }
    }


    /**
     *  Accessor that sets the <code>MazeViewer</code> variable for
     *  the maze.  When the viewer is not set, no visualization takes place.
     *  @param viewer Visual display place for the maze.
     */
    public void setViewer(MazeViewer viewer) {
        this.viewer = viewer;
    }

    /**
     *  Accessor that sets the start cell for the maze.
     *  @param cell Start cell for the maze.
     */
    public void setStartCell(MazeCell cell) {
       startCell = cell;
    }

    /**
     *  Accessor that sets the end cell for the maze.
     *  @param cell End cell for the maze.
     */
    public void setEndCell(MazeCell cell) {
        endCell = cell;
    }

    /**
     *  Accessor that returns the start cell for the maze.
     *  @return Start cell for the maze.
     */
    public MazeCell getStartCell() {
        return startCell;
    }

    /**
     *  Accessor that returns the end cell for the maze.
     *  @return End cell for the maze.
     */
    public MazeCell getEndCell() {
        return endCell;
    }

    /**
     *  Accessor that returns the number of rows in the maze.
     *  @return The number of rows in the maze.
     */
    public int getRows() {
        return rows;
    }

    /**
     *  Accessor that returns the number of columns in the maze.
     *  @return The number of columns in the maze.
     */
    public int getCols() {
        return cols;
    }

    /**
     *  Returns the cell in the maze at the given coordinates.
     *  @param row  The row in the maze of the cell.
     *  @param col  The column in the maze of the cell.
     *  @return  The cell at (<code>row</code>, <code>col</code>)
     */
    public MazeCell getCell(int row, int col) {
        //TODO - correct this.
    	return maze[row][col];
        //return null;
    }

    /**
     *  Tells the viewer to show the maze again, with 
     *  any changes to cells updated.  The current cell 
     *  will be colored in the viewer.  If the viewer is null,
     *  this method does nothing.
     *  @param cell Current cell, that the viewer will color.
     */
    public synchronized void visualize(MazeCell cell) {
        //TODO - call the appropriate method from MazeViewer to visualize
    	viewer.visualize(cell);
    }

    /**
     *  Generates the maze. 
     *  The maze is generated by Kruskal's algorithm
     */
    public synchronized void generateMaze() {
        makeKruskalMaze();
        //you can change the startCell and endCell values
        startCell = maze[0][0];
        endCell = maze[rows-1][cols-1];
    }
    

    /**
     *  Forms the maze via Kruskal's algorithm.
     */
    public synchronized void makeKruskalMaze() {
        //TODO - use a modified version of Kruskal's algorithm to make the maze
    	sets = new DisjointSet(maze);
    	int numCells = rows * cols;
    	int wallsDown = 0;
    	while (wallsDown < numCells - 1) {
    		int ranR = this.generator.nextInt(rows);
    		int ranC = this.generator.nextInt(cols);
    		MazeCell currCell = maze[ranR][ranC];
    		
    		LinkedList<MazeCell> neighborWallBetween = new LinkedList<MazeCell>();	
    		if (currCell.east() && currCell.getNeighborE() != null) {
    			neighborWallBetween.add(currCell.getNeighborE());
    		}
    		if (currCell.west() && currCell.getNeighborW() != null) {
    			neighborWallBetween.add(currCell.getNeighborW());
    		}
    		if (currCell.south() && currCell.getNeighborS() != null) {
    			neighborWallBetween.add(currCell.getNeighborS());
    		}
    		if (currCell.north() && currCell.getNeighborN() != null) {
    			neighborWallBetween.add(currCell.getNeighborN());
    		}

    		if (neighborWallBetween.size() == 0) {
    			continue;
    		}
    		
    		MazeCell neighborToDownWall = 
    				neighborWallBetween.get(this.generator.nextInt(neighborWallBetween.size()));
    		
    		if (sets.find(currCell) != sets.find(neighborToDownWall)) {
    			sets.union(currCell, neighborToDownWall);
    			currCell.knockDownWall(neighborToDownWall);
    			wallsDown++;
    		}
    		
    	}
    	
    }
    
    

    /**
     *  Solve maze.  The input parameter is guaranteed
     *  to be one of "dfs", "bfs",  or "random".
     *  @param method The method for solving the maze; one of
     *                "dfs" = depth first search, 
     *                "bfs" = breadth first search, 
     *                "random" = random walk.
     */
    public synchronized void solveMaze(String method) {
        //TODO - call the appropriate solution method
    	if (method.equals("random")) {
    		System.out.println("Solving randomly.");
    		solveRandomMaze();
    	} else if (method.equals("dfs")) {
    		System.out.println("Solving dfs");
    		solveDFSMaze();
    	} else if (method.equals("bfs")) {
    		System.out.println("Solving bfs");
    		solveBFSMaze();
    	} else {
    		System.out.println("NonSolved");
    	}
    }

    /**
     *  Solves the maze by randomly choosing a neighboring
     *  cell to explore. This method has been written for you.
     *  Please note this method takes a very long time
     *  to complete.
     */
    public synchronized void solveRandomMaze() {
        // Start the search at the start cell
        MazeCell current = startCell;

        // while we haven't reached the end of the maze
        while(current != endCell) { 
            visualize(current); // show the progress visually (repaint)
            MazeCell neighbors[] = current.getNeighbors();
            int index = generator.nextInt(neighbors.length);
            current.examine();
            current = neighbors[index];    
        }
        visualize(current);
    }

    /**
     *  Solves the maze by depth first search.
     */
    public synchronized void solveDFSMaze() {
        //TODO - do a DFS implementation
    	MazeCell source = startCell;
    	Stack<MazeCell> S = new Stack<>();
    	source.visit();
    	S.push(source);
    	visualize(source);
    	MazeCell current = source;
    	while(!S.isEmpty() && current != endCell){
    		current = S.peek();
    		MazeCell[] neighbors = current.getNeighbors();
    		boolean noNeighbors = true;
    		for (MazeCell tempCell : neighbors) {
    			if (!tempCell.visited() && !tempCell.examined()) {
    				current = tempCell;
    				current.visit();
    				visualize(current);
    				S.push(current);
    				noNeighbors = false;
    				break;
    			}
    		}
    		if (noNeighbors == true) {
    			current = S.pop();
    			current.examine();
    			visualize(current);
    		}
    	}
    	visualize(current);
    }

    /**
     *  Solves the maze by breadth first search.
     *  starts at the start vertex and stops when bfs
     *  discovers the end vertex
     */
    public synchronized void solveBFSMaze() {
        //TODO - do a BFS implementation
    	MazeCell source = startCell;
    	Queue<MazeCell> Q = new LinkedList<>();
    	source.visit();
    	source.setPredecessor(null);
    	Q.add(source);
    	visualize(source);
    	MazeCell current = source;
    	while (!Q.isEmpty() && current != endCell) {
    		current = Q.poll();
    		current.visit();
    		MazeCell[] neighbors = current.getNeighbors();
    		for (MazeCell tempCell : neighbors) {
    			if (!tempCell.examined() && !tempCell.visited()) {
    				tempCell.setPredecessor(current);
    				visualize(tempCell);
    				tempCell.visit();
    				Q.add(tempCell);
    			}
    			if (tempCell == endCell) {
    				current = tempCell;
    				break;
    			}
    		}
    		
    	}
    	current.examine();
    	while (current != startCell && current != null) {
    		current = current.getPredecessor();
    		current.examine();
    		visualize(current);
    	}
    	//visualize(current);
    }


}

